(defun randval (v)
  (if (<= v 0)
      v
      (random v)))

(defun partial-fill (region)
  (let* ((region-offset (cons (loop for pos in region minimize (car pos))
			      (loop for pos in region minimize (cdr pos))))
	 (region-size (cons (- (loop for pos in region maximize (car pos))
			       (car region-offset))
			    (- (loop for pos in region maximize (cdr pos))
			       (cdr region-offset))))
	 (fill-size (cons (+ 3 (randval (- (car region-size) 3)))
			  (+ 3 (randval (- (cdr region-size) 3)))))
	 (fill-offset (cons (randval (- (car region-size)
					(car fill-size)))
			    (randval (- (cdr region-size)
					(cdr fill-size))))))
    (apply #'append
	   (loop for x below (car fill-size)
		 collect (loop for y below (cdr fill-size)
			       collect (cons (+ (car fill-offset)
						(car region-offset)
						x)
					     (+ (cdr fill-offset)
						(cdr region-offset)
						y)))))))

(defun foo (board &optional (depth 0))
  (let* ((board-offset (cons (loop for pos in board minimize (car pos))
			     (loop for pos in board minimize (cdr pos))))
	 (board-size (cons (- (loop for pos in board maximize (car pos))
			      (car board-offset))
			   (- (loop for pos in board maximize (cdr pos))
			      (cdr board-offset))))
	 (partition-1 nil)
	 (partition-2 nil)
	 (split-direction (cond ((> 6 (car board-size)) 'v)
				((> 6 (cdr board-size)) 'h)
				(t (if (= (random 2) 0) 'h 'v))))
	 (variance (cons (- (car board-size) 6)
			 (- (cdr board-size) 6)))
	 (split-position (if (eq split-direction 'h)
			     (+ (/ (car board-size) 2)
				(car board-offset)
				(randval (1+ (car variance)))
				(- (max 0 (/ (car variance) 2))))
			     (+ (/ (cdr board-size) 2)
				(cdr board-offset)
				(randval (1+ (cdr variance)))
				(- (max 0 (/ (cdr variance) 2)))))))
    (if (< depth 4)
	(progn
	  (loop for pos in board
		do (if (eq split-direction 'h)
		       (if (<= (car pos) split-position)
			   (push pos partition-1)
			   (push pos partition-2))
		       (if (<= (cdr pos) split-position)
			   (push pos partition-1)
			   (push pos partition-2))))
	  (cons (foo partition-1 (1+ depth))
		(list (foo partition-2 (1+ depth)))))
	(partial-fill board))))

(defun main (size)
  (let ((board (foo (apply #'append (loop for x below (car size)
					  collect (loop for y below (cdr size)
							collect (cons x y))))))
	(printing (make-hash-table :test 'equal)))
    (labels ((bar (l)
	       (if (= (length l) 2)
		   (progn (bar (car l))
			  (bar (cadr l)))
		   (loop for pos in l
			 do (setf (gethash pos printing) #\#)))))
      (bar board))
    (format t "~{~{~c~}~%~}"
	    (loop for y below (cdr size)
		  collect (loop for x below (car size)
				collect (let ((c (gethash
						  (cons x y)
						  printing)))
					  (if c c #\space))))))
  (unless (eq (read-char) #\q)
    (format t "-------------------------------------------------~%")
    (main size)))

(main '(50 . 20))
