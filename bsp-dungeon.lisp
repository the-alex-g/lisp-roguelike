(defun randval (v)
  (if (<= v 1)
      0
      (random (round v))))

(defun partial-fill (offset size)
  (let* ((fill-size (cons (+ 3 (randval (- (car size) 4)))
			  (+ 3 (randval (- (cdr size) 4)))))
	 (fill-offset (cons (round (+ 1 (car offset)
				      (randval (- (car size) (car fill-size) 1))))
			    (round (+ 1 (cdr offset)
				      (randval (- (cdr size) (cdr fill-size) 1)))))))
    (apply #'append
	   (loop for y below (cdr fill-size)
		 collect (loop for x below (car fill-size)
			       collect (add-pos fill-offset (cons x y)))))))

(defun connect (r1 r2)
  (let* ((rooms (append (car r1) (car r2)))
	 (corridors (append (cdr r1) (cdr r2)))
	 (region (pos-flatten (append rooms corridors))))
    (if (loop for r in rooms always r)
	(let* ((region2 (pos-flatten r2))
	       (cp1 (randnth (pos-flatten r1)))
	       (px (loop for point in region2
			 with minx = 1000
			 when (< (abs (- (car cp1) (car point))) minx)
			   do (setf minx (car point))
			 finally (return minx)))
	       (py (loop for point in region2
			 with miny = 1000
			 when (and (eq (car point) px)
				   (abs (- (cdr cp1) (cdr point))))
			   do (setf miny (cdr point))
			 finally (return miny)))
	       (dx (- px (car cp1)))
	       (dy (- py (cdr cp1)))
	       (cp2 (cons px py)))
	  (flet ((region-member (point) (member point region :test 'equal)))
	    (let ((new-corridor (append
				 (unless (eq (cdr cp1) (cdr cp2))
				   (flet ((get-point (y)
					    (cons (car cp1)
						  (if (< dy 0)
						      (- (cdr cp1) y)
						      (+ (cdr cp1) y)))))
				     (loop for y from 0 to (abs dy)
					   unless (region-member (get-point y))
					     collect (get-point y)
					   finally (setf cp1 (cons (car cp1)
								   (cdr cp2))))))
				 (unless (eq (car cp1) (car cp2))
				   (flet ((get-point (x)
					    (cons (if (< dx 0)
						      (- (car cp1) x)
						      (+ (car cp1) x))
						  (cdr cp1))))
				     (loop for x from 0 to (abs dx)
					   unless (region-member (get-point x))
					     collect (get-point x)))))))
	      (if new-corridor
		  (cons rooms (cons new-corridor corridors))
		  (cons rooms corridors)))))
	(cons rooms corridors))))

(defun vary-from (val)
  (if (<= val 8)
      4
      (+ val (round (* (1- (random 2.0))
		       (/ val 2))))))

(defun partition (offset size max-depth &optional (cur-depth 0))
  (if (< cur-depth max-depth)
      (let* ((split-direction (cond ((> 8 (car size)) 'h)
				    ((> 8 (cdr size)) 'v)
				    (t (if (= (random 2) 0) 'h 'v))))
	     (split (if (eq split-direction 'h)
			(vary-from (/ (cdr size) 2))
			(vary-from (/ (car size) 2)))))
	(if (eq split-direction 'v)
	    (connect (partition offset
				(cons split (cdr size))
				max-depth (1+ cur-depth))
		     (partition (cons (+ (car offset) split) (cdr offset))
				(cons (- (car size) split) (cdr size))
				 max-depth (1+ cur-depth)))
	    (connect (partition offset
				(cons (car size) split)
				max-depth (1+ cur-depth))
		     (partition (cons (car offset) (+ (cdr offset) split))
				(cons (car size) (- (cdr size) split))
				max-depth (1+ cur-depth)))))
      (list (list (partial-fill offset size)))))

(defun generate-dungeon (size depth)
  (partition '(0 . 0) size depth))

;; a function for testing the boards
(defun main (size depth)
  (let* ((board (generate-dungeon size depth))
	 (rooms (pos-flatten (car board)))
	 (corridors (pos-flatten (cdr board)))
	 (corridor-endpoints (loop for corridor in (append (cdr board))
				   collect (car corridor)
				   collect (car (last corridor)))))
    (format t "~{~{~c~}~%~}"
	    (loop for y below (cdr size)
		  collect (loop for x below (car size)
				collect (cond ((member (cons x y)
						       corridor-endpoints
						       :test 'equal)
					       #\S)
					      ((member (cons x y)
						       corridors
						       :test 'equal)
					       #\.)
					      ((member (cons x y)
						       rooms
						       :test 'equal)
					       #\#)
					      (t #\space))))))
  (unless (eq (read-char) #\q)
    (format t "-------------------------------------------------~%")
    (main size depth)))
