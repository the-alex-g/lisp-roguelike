(defun randval (v)
  (if (<= v 0)
      v
      (random v)))

(defun partial-fill (region)
  (let* ((region-offset (cons (loop for pos in region minimize (car pos))
			      (loop for pos in region minimize (cdr pos))))
	 (region-size (cons (- (loop for pos in region maximize (car pos))
			       (car region-offset))
			    (- (loop for pos in region maximize (cdr pos))
			       (cdr region-offset))))
	 (fill-size (cons (+ 3 (randval (- (car region-size) 3)))
			  (+ 3 (randval (- (cdr region-size) 3)))))
	 (fill-offset (cons (randval (- (car region-size)
					(car fill-size)))
			    (randval (- (cdr region-size)
					(cdr fill-size))))))
    (apply #'append
	   (loop for x below (car fill-size)
		 collect (loop for y below (cdr fill-size)
			       collect (cons (+ (car fill-offset)
						(car region-offset)
						x)
					     (+ (cdr fill-offset)
						(cdr region-offset)
						y)))))))

(defun connect (r1 r2)
  (let ((region (append r1 r2)))
    (when (and r1 r2)
      (let* ((cp1 (nth (randval (length r1)) r1))
	     (cp2 (loop for point in r2
			when (or (= (car point) (car cp1))
				 (= (cdr point) (cdr cp1)))
			  return point)))
	(unless cp2
	  (setf cp2 (nth (randval (length r2)) r2)))
	(unless (eq (cdr cp1) (cdr cp2))
	  (loop for y from 0 to (- (cdr cp2) (cdr cp1))
		do (push (cons (car cp1)
			       (+ (cdr cp1) y))
			 region)))
	(unless (eq (car cp1) (car cp2))
	  (loop for x from 0 to (- (car cp2) (car cp1))
		do (push (cons (+ (car cp1) x)
			       (cdr cp2))
			 region)))))
    region))

(defun partition (board max-depth &optional (cur-depth 0))
  (let* ((board-offset (cons (loop for pos in board minimize (car pos))
			     (loop for pos in board minimize (cdr pos))))
	 (board-size (cons (- (loop for pos in board maximize (car pos))
			      (car board-offset))
			   (- (loop for pos in board maximize (cdr pos))
			      (cdr board-offset))))
	 (partition-1 nil)
	 (partition-2 nil)
	 (split-direction (cond ((> 6 (car board-size)) 'v)
				((> 6 (cdr board-size)) 'h)
				(t (if (= (random 2) 0) 'h 'v))))
	 (variance (cons (- (car board-size) 6)
			 (- (cdr board-size) 6)))
	 (split-position (if (eq split-direction 'h)
			     (+ (/ (car board-size) 2)
				(car board-offset)
				(randval (1+ (car variance)))
				(- (max 0 (/ (car variance) 2))))
			     (+ (/ (cdr board-size) 2)
				(cdr board-offset)
				(randval (1+ (cdr variance)))
				(- (max 0 (/ (cdr variance) 2)))))))
    (if (< cur-depth max-depth)
	(progn
	  (loop for pos in board
		do (if (eq split-direction 'h)
		       (if (<= (car pos) split-position)
			   (push pos partition-1)
			   (push pos partition-2))
		       (if (<= (cdr pos) split-position)
			   (push pos partition-1)
			   (push pos partition-2))))
	  (connect (partition partition-1 max-depth (1+ cur-depth))
		  (partition partition-2 max-depth (1+ cur-depth))))
	(partial-fill board))))

;; a function for testing the boards
(defun main (size)
  (let ((board (partition (apply #'append
				 (loop for x below (car size)
				       collect (loop for y below (cdr size)
						     collect (cons x y))))
			  4)))
    (format t "~{~{~c~}~%~}"
	    (loop for y below (cdr size)
		  collect (loop for x below (car size)
				collect (if (member (cons x y)
						    board
						    :test 'equal)
					    #\#
					    #\space)))))
  (unless (eq (read-char) #\q)
    (format t "-------------------------------------------------~%")
    (main size)))

(defun generate-board (size depth)
  (partition (apply #'append
		    (loop for x below (car size)
			  collect (loop for y below (cdr size)
					collect (cons x y))))
	     depth))
