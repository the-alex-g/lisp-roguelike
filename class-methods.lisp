(defgeneric drop-corpse (obj))

(defgeneric kill (obj)
  (:method (obj))
  (:method ((obj enemy))
    (drop-corpse obj))
  (:method :before ((obj creature))
    (remove-solid (pos obj))
    (remove-glowing obj)))

(defgeneric wallp (obj)
  (:method (obj) nil)
  (:method ((obj list)) (wallp (solid obj)))
  (:method ((obj symbol)) (eq obj 'wall))
  (:method ((obj character)) t))

(defgeneric playerp (obj)
  (:method ((obj player)) t)
  (:method (obj) nil))

(defmethod name ((obj character)) "wall")
(defmethod name ((obj symbol)) obj)
(defmethod name ((obj secret-equipment))
  (if (identifiedp obj)
      (slot-value obj 'name)
      (cover-name obj)))

(defgeneric sell-price (item)
  (:method ((item equipment))
    (ash (price item) -1)))

(defgeneric color (obj)
  (:method ((obj number))
    obj)
  (:method ((obj symbol))
    (let ((color-set (assoc obj *colors*)))
      (if color-set
	  (cadr color-set)
	  0)))
  (:method ((obj list))
    (apply #'calculate-color obj))
  (:method ((obj actor))
    (let* ((stored-value (slot-value obj 'color))
	   (color (color stored-value)))
      (unless (numberp stored-value)
	(setf (slot-value obj 'color) color))
      color)))

(defgeneric display-char (obj)
  (:method ((obj actor))
    (if (eq (color obj) 30)
	(slot-value obj 'display-char)
	(apply-color (slot-value obj 'display-char) (color obj))))
  (:method ((pos list))
    (if (and (wallp (vec+ pos +up+))
	     (wallp (vec+ pos +down+)))
	(setf (solid pos) #\|)
	(setf (solid pos) #\-)))
  (:method ((obj character)) obj))

(defmethod evasion ((obj creature))
  (max 1 (+ 5 (dex obj) (slot-value obj 'evasion))))

(defgeneric deadp (obj)
  (:method ((obj creature))
    (= (health obj) 0)))

(defmethod (setf health) (value (obj creature))
  (if (> value 0)
      (if (slot-boundp obj 'max-health)
	  (setf (slot-value obj 'health) (min value (max-health obj)))
	  (progn (setf (slot-value obj 'max-health) (health obj))
		 (setf (slot-value obj 'health) value)))
      (progn (setf (slot-value obj 'health) 0)
	     (kill obj))))

(defmethod (setf con) (value (obj creature))
  (let ((dhealth (- value (con obj))))
    (incf (slot-value obj 'max-health)
	  dhealth)
    (incf (health obj) dhealth)))

(defmethod (setf hunger) (value (obj player))
  (cond ((> value (max-hunger obj))
	 (setf (slot-value obj 'hunger) (max-hunger obj)))
	((< value 0)
	 (setf (slot-value obj 'hunger) 20)
	 (decf (health obj)))
	(t
	 (setf (slot-value obj 'hunger) value))))

(defmethod (setf illumination) (value (obj actor))
  (let ((current-value (illumination obj)))
    (when (and (<= current-value 0)
	       (> value 0))
      (add-glowing obj))
    (when (and (> current-value 0)
	       (<= value 0))
      (remove-glowing obj)))
  (setf (slot-value obj 'illumination) value))
  
(defgeneric death (obj)
  (:method ((obj creature))
    "killing it"))

(defgeneric resistp (obj type)
  (:method ((obj creature) type)
    (member type (resistances obj))))

(defgeneric immunep (obj type)
  (:method ((obj creature) type)
    (member type (immunities obj))))

(defgeneric vulnerablep (obj type)
  (:method ((obj creature) type)
    (member type (vulnerabilities obj))))

(defgeneric absorbp (obj type)
  (:method ((obj creature) type)
    (member type (absorbances obj))))

(defgeneric weapons (obj)
  (:method ((obj creature))
    (let ((held-items (gethash 'hand (equipment obj))))
      (cond ((= (length held-items) 1)
	     held-items)
	    ((= (length held-items) 0)
	     (list (make-fist)))
	    (t
	     (loop for equipment in held-items
		   when (weaponp equipment)
		     collect equipment))))))

(defgeneric description (obj)
  (:method ((obj equipment))
    (log-to-string "takes ~d ~a slots~%deals ~a as a weapon~:[~;~%~:*~a~]"
		   (size obj)
		   (equip-slot obj)
		   (damage-string (atk obj))
		   (slot-value obj 'description))))

(defgeneric identify (obj)
  (:method ((obj secret-equipment))
    (setf (identifiedp obj) t)))

(defgeneric meat (obj)
  (:method ((obj enemy))
    (let ((meat (slot-value obj 'meat)))
      (if meat
	  (if (numberp meat)
	      (make-instance 'food :sustenance meat
				   :name (log-to-string "~a meat" (name obj)))
	      meat)))))

(defgeneric breaksp (obj &optional offset)
  (:method ((obj equipment) &optional (offset 0))
    (< (random 100)
	(max (min 1 (break-chance obj))
	     (- (break-chance obj) offset)))))

(defun get-loot (obj)
  (let ((loot '()))
    (when (meat obj)
      (push (meat obj) loot))
    (loop for item in (loot obj)
	  if (and item (atom item))
	    do (push item loot)
	  else
	    do (let ((bit (eval-weighted-list item)))
		 (when (car bit)
		   (mapc (lambda (b) (push b loot)) bit))))
    (loop for item-list being the hash-values of (equipment obj)
	  do (loop for item in item-list
		   unless (breaksp item 50)
		     do (push item loot)))
    loot))

(defun has-status-p (obj status-name)
  (loop for status in (statuses obj)
	thereis (eq status-name (type-of status))))

(defgeneric remove-status (status)
  (:method :after ((status status))
    (setf (statuses (target status))
	  (remove status
		  (statuses (target status)))))
  (:method (status)))
