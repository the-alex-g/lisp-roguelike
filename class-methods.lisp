(defgeneric drop-corpse (obj))

(defgeneric kill (obj)
  (:method (obj))
  (:method ((obj enemy))
    (drop-corpse obj))
  (:method :before ((obj creature))
    (remove-solid (pos obj))
    (remove-glowing obj)))

(defgeneric wallp (obj)
  (:method (obj) nil)
  (:method ((obj list)) (wallp (solid obj)))
  (:method ((obj symbol)) (eq obj 'wall))
  (:method ((obj character)) (or (eq obj #\|) (eq obj #\-))))

(defgeneric playerp (obj)
  (:method ((obj player)) t)
  (:method (obj) nil))

(defmethod name ((obj character)) "wall")
(defmethod name ((obj symbol)) obj)
(defmethod name ((obj secret-equipment))
  (if (identifiedp obj)
      (slot-value obj 'name)
      (cover-name obj)))

(defmethod stationaryp ((obj creature))
  nil)

(defgeneric sell-price (item)
  (:method ((item equipment))
    (ash (price item) -1)))

(defgeneric color (obj)
  (:method (obj)
    7)
  (:method ((obj number))
    obj)
  (:method ((obj symbol))
    (let ((color-set (assoc obj *colors*)))
      (if color-set
	  (cadr color-set)
	  0)))
  (:method ((obj list))
    (apply #'calculate-color obj))
  (:method ((obj actor))
    (let* ((stored-value (slot-value obj 'color))
	   (color (color stored-value)))
      (unless (numberp stored-value)
	(setf (slot-value obj 'color) color))
      color)))

(defgeneric bg-color (obj)
  (:method ((obj actor))
    (when (slot-value obj 'bg-color)
      (color (slot-value obj 'bg-color))))
  (:method ((pos list))
    (if (non-solid pos)
	(bg-color (non-solid pos))
	(bg-color (terrain pos))))
  (:method ((obj (eql nil))) nil)
  (:method (obj) nil)
  (:method ((obj symbol)) nil))

(defgeneric display-char (obj)
  (:method ((obj actor))
    (let ((text (if (eq (color obj) 30)
		    (slot-value obj 'display-char)
		    (apply-color (slot-value obj 'display-char) (color obj)))))
      (if (bg-color obj)
	  (apply-color text (bg-color obj) :bg t)
	  (if (bg-color (pos obj))
	      (apply-color text (bg-color (pos obj)) :bg t)
	      text))))
  (:method ((pos list))
    (if (wallp pos)
	(if (and (wallp (vec+ pos +up+))
		 (wallp (vec+ pos +down+)))
	    (setf (solid pos) #\|)
	    (setf (solid pos) #\-))
	(display-char (terrain pos))))
  (:method ((obj character)) obj)
  (:method ((obj symbol))
    (apply-color (gethash obj *terrain-characters*)
		 (gethash obj *terrain-colors*))))

(defmethod evasion ((obj creature))
  (max 1 (+ 5 (dex obj) (slot-value obj 'evasion))))

(defgeneric deadp (obj)
  (:method ((obj creature))
    (= (health obj) 0)))

(defmethod (setf health) (value (obj creature))
  (if (> value 0)
      (if (slot-boundp obj 'max-health)
	  (setf (slot-value obj 'health) (min value (max-health obj)))
	  (progn (setf (slot-value obj 'max-health) (health obj))
		 (setf (slot-value obj 'health) value)))
      (progn (setf (slot-value obj 'health) 0)
	     (kill obj))))

(defmethod (setf con) (value (obj creature))
  (let ((dhealth (- value (con obj))))
    (incf (slot-value obj 'max-health)
	  dhealth)
    (incf (health obj) dhealth)))

(defmethod (setf hunger) (value (obj player))
  (cond ((> value (max-hunger obj))
	 (setf (slot-value obj 'hunger) (max-hunger obj)))
	((< value 0)
	 (setf (slot-value obj 'hunger) 20)
	 (decf (health obj)))
	(t
	 (setf (slot-value obj 'hunger) value))))

(defmethod (setf illumination) (value (obj actor))
  (let ((current-value (illumination obj)))
    (when (and (<= current-value 0)
	       (> value 0))
      (add-glowing obj))
    (when (and (> current-value 0)
	       (<= value 0))
      (remove-glowing obj)))
  (setf (slot-value obj 'illumination) value))
  
(defgeneric death (obj)
  (:method ((obj creature))
    "killing it"))

(defgeneric weapons (obj)
  (:method ((obj creature))
    (let ((held-items (gethash 'hand (equipment obj))))
      (cond ((= (length held-items) 1)
	     held-items)
	    ((= (length held-items) 0)
	     (list (make-fist)))
	    (t
	     (loop for equipment in held-items
		   when (weaponp equipment)
		     collect equipment))))))

(defgeneric description (obj)
  (:method ((obj equipment))
    (log-to-string "takes ~d ~a slots~%deals ~a as a weapon~:[~;~%~:*~a~]"
		   (size obj)
		   (equip-slot obj)
		   (damage-string (atk obj))
		   (slot-value obj 'description))))

(defgeneric identify (obj)
  (:method ((obj secret-equipment))
    (setf (identifiedp obj) t)))

(defgeneric meat (obj)
  (:method ((obj enemy))
    (let ((meat (slot-value obj 'meat)))
      (if meat
	  (if (numberp meat)
	      (make-instance 'food :sustenance meat
				   :name (log-to-string "~a meat" (name obj)))
	      meat)))))

(defgeneric breaksp (obj &optional offset)
  (:method ((obj equipment) &optional (offset 0))
    (< (random 100)
	(max (min 1 (break-chance obj))
	     (- (break-chance obj) offset)))))

(defun get-loot (obj)
  (let ((loot '()))
    (when (meat obj)
      (push (meat obj) loot))
    (loop for item in (loot obj)
	  if (and item (atom item))
	    do (push item loot)
	  else
	    do (let ((bit (eval-weighted-list item)))
		 (when (car bit)
		   (mapc (lambda (b) (push b loot)) bit))))
    (loop for item-list being the hash-values of (equipment obj)
	  do (loop for item in item-list
		   unless (breaksp item 50)
		     do (push item loot)))
    loot))

(defun has-status-p (obj status-name)
  (loop for status in (statuses obj)
	thereis (eq status-name (type-of status))))

(defgeneric remove-status (status)
  (:method :after ((status status))
    (setf (statuses (target status))
	  (remove status
		  (statuses (target status)))))
  (:method (status)))

(macrolet ((define-damage-mod-accessors (name)
	     `(progn (defgeneric ,name (obj)
		       (:method ((obj creature))
			 (let ((damage-types (slot-value obj ',name)))
			   (if (numberp damage-types)
			       damage-types
			       (let ((mask (make-mask damage-types)))
				 (setf (,name obj) mask)
				 mask)))))
		     (defgeneric (setf ,name) (value obj)
		       (:method ((value number) (obj creature))
			 (setf (slot-value obj ',name) value))
		       (:method ((value list) (obj creature))
			 (setf (slot-value obj ',name) (make-mask value)))))))
  (define-damage-mod-accessors resistances)
  (define-damage-mod-accessors immunities)
  (define-damage-mod-accessors absorbances)
  (define-damage-mod-accessors vulnerabilities))
